## Ping pong
_from [[ Chapter 3. Data Structures :: Maintaining Interval Data :: Examples | Chapter 3. Data Structures ]]_

### Description
有 _N_ （3 ≤ _N_ ≤ 20000）个乒乓球球员住在一条东西向的街上（可以把这个街认为是一条直线），每个球员都有唯一的排名。

为了提高他们的排名，他们经常互相挑战。如果两名球员想要进行一场比赛，他们必须选择另一名球员当比赛的裁判，并且比赛在裁判的房子里举办。由于某些原因，选手不可以选择排名比他们两个都低或者都高的球员作裁判。并且因为选手必须走路到裁判的房子参加比赛，所以选手希望他们走路的路径之和，不超过他们房屋的距离。（每位选手都很懒）

球员们都住在不同的房子中，没有两座房子在同一个地方。如果有两场比赛的裁判或任意一名球员不相同，我们就认为这是不同的两场比赛。现在问题来了：在这条乒乓球街上，可以举办多少种不同的比赛？

### Input
输入的第一行是一个整数 _T_ （1 ≤ _T_ ≤ 20），表示有几组测试数据。紧接着有 _T_ 行数据，每行表示一组测试数据。

每组测试数据包含 _N_ + 1个整数。第一个整数是 _N_ ，表示球员数。之后有N个不同的整数 _a<sub>1</sub>_ , _a<sub>2</sub>_ , ... , _a<sub>N</sub>_ ，按住处从西到东的顺序表示每个球员的排名（1 ≤ _a<sub>i</sub>_ ≤ 100000, _i_ = 1... _N_ ）。

### Output
对于所有的测试数据，每行输出一个整数，表示可以举办的不同比赛的场数。

### Solution
原题相当于给出一组序列 _a<sub>1</sub>_ , _a<sub>2</sub>_ , ... , _a<sub>n</sub>_ ，可以找出有多少组 _i_ , _j_ , _k_ 符合 _i_ ≤ _j_ ≤ _k_ ，且 _a<sub>i</sub>_ ≤ _a<sub>j</sub>_ ≤ _a<sub>k</sub>_ 或 _a<sub>i</sub>_ ≥ _a<sub>j</sub>_ ≥ _a<sub>k</sub>_ 成立。

我们可以枚举上述不等式中间的 _a<sub>j</sub>_ ，设 _a<sub>1</sub>_ 到 _a<sub>j-1</sub>_ 中有 _x<sub>j</sub>_ 个比 _a<sub>j</sub>_ 小，则有 ( _j_ - 1 - _x<sub>j</sub>_ ) 个比 _a<sub>j</sub>_ 大；同理，设 _a<sub>j+1</sub>_ 到 _a<sub>N</sub>_ 中有 _y<sub>j</sub>_ 个比 _a<sub>j</sub>_ 小，则有 ( _N_ - _j_ - _y<sub>j</sub>_ ) 个比 _a<sub>j</sub>_ 大。所以当 _a<sub>i</sub>_ ≤ _a<sub>j</sub>_ ≤ _a<sub>k</sub>_ 时， _i_ 和 _k_ 一共有 _x<sub>j</sub>_ · ( _N_ - _j_ - _y<sub>j</sub>_ ) 种组合，而当 _a<sub>i</sub>_ ≥ _a<sub>j</sub>_ ≥ _a<sub>k</sub>_ 时， _i_ 和 _k_ 一共有种 ( _j_ - 1 - _x<sub>j</sub>_ ) · _y<sub>j</sub>_ 组合，最后的答案就是 [ _x<sub>j</sub>_ ( _N_ - _j_ - _y<sub>j</sub>_ ) + ( _j_ - 1 - _x<sub>j</sub>_ ) _y<sub>j</sub>_ ] 。

剩下的工作就是求出 _x<sub>i</sub>_ 和 _y<sub>i</sub>_ 了。 _x<sub>i</sub>_ 可以这样计算：从左往右扫描 _a<sub>i</sub>_ ，用 `c[v]` 表示 _a<sub>1</sub>_ , _a<sub>2</sub>_ , ... , _a<sub>i-1</sub>_ 中， 值等于 `v` 的 _a<sub>i</sub>_ 是否出现（用 `c[v] = 0` 表示未出现， `c[v] = 1` 表示已出现），则 _x<sub>i</sub>_ = sum( _a<sub>1</sub>_ , _a<sub>2</sub>_ , ... , _a<sub>i-1</sub>_ )。一开始 `c[v]` 初始化为0，在计算出 _x<sub>i</sub>_ 之后，将 `c[v]` ( `v` = _a<sub>i</sub>_ ) 标记为1，然后继续扫描 _a<sub>i+1</sub>_ 。为什么这么做呢？因为在这之中的 “求和” 和 “标记” 的操作正好是二叉索引树的经典用法。最后我们可以再从右往左扫描 _a<sub>i</sub>_ ，用同样的方法求出 _y<sub>i</sub>_ 就可以了。

这个算法的时间复杂度为 _O(n·log(max{a<sub>i</sub>}))_ 。
